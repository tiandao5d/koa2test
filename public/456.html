<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="font-awesome-4.7.0/css/font-awesome.css">
  <link rel="stylesheet" href="css/ol.css">
  <script src="js/ol.js"></script>
  <style>
    #map {
      position: fixed;
      top: 100px;
      left: 0;
      bottom: 0;
      right: 0;
    }

  </style>
</head>

<body>
    <i class="fa fa-thermometer-three-quarters" aria-hidden="true"></i>
  <div id="map" class="map"></div>
  <form>
    <label>cluster distance</label>
    <input id="distance" type="range" min="0" max="100" step="1" value="40" />
  </form>
  <script>
    class CPointStyle {
      constructor (imgsrc) {
        this.dimg = imgsrc || 'images/001.png'; // 默认图片，如果某些图片无法加载就用这个代替
      }
      // imgsrc 图片地址
      // size 转换后的canvas宽高 [20, 20]
      imgToCanvas(imgsrc, size) {
        let that = this;
        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');
        let img = new Image();
        return new Promise(a => {
          img.onload = () => {
            if (!size) {
              size = [];
              size[0] = img.width;
              size[1] = img.height;
            }
            canvas.width = size[0];
            canvas.height = size[1];
            ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, size[0], size[1]);
            a(canvas);
          }
          img.onerror = () => {
            that.imgToCanvas(that.dimg, size).then(s => {
              a(s);
            })
          }
          img.src = imgsrc || that.dimg;
        })
      }
      // imgs = [{src: '', size: [20, 20]}]
      // keys = ['src', 'size'],用于指定imgs中对象的key值的字符串，然后imgs对象中的src，size可以使任何字段名
      async imgsTocvs (imgs, keys = {src: 'src', size: 'size'}) {
        let pls = imgs.map(o => this.imgToCanvas(o[keys.src], o[keys.size]));
        return Promise.all(pls);
      }

      // 快速创建一个ol.style.Icon
      // 推荐直接使用canvas
      olIcon ( canvas = {}, obj = {} ) {
        return new ol.style.Style(Object.assign({
          image: new ol.style.Icon(Object.assign({
            img: canvas,
            imgSize: [canvas.width, canvas.height]
          }, obj.oIcon)),
          zIndex: obj.zIndex
        }, obj.oStyle));
      }
      // 快速创建一个ol.style.Text
      olText ( obj = {} ) {
        let stroke, fill;
        if ( obj.strokeColor || obj.strokeWidth ) {
          stroke = new ol.style.Stroke({
              color: obj.strokeColor,
              width: obj.strokeWidth
            })
        }
        if ( obj.fillColor ) {
          fill = new ol.style.Fill({
              color: obj.fillColor
            })
        }
        return new ol.style.Style(Object.assign({
          text: new ol.style.Text(Object.assign({
            text: obj.text || '',
            font: obj.font,
            fill: fill,
            stroke: stroke
          }, obj.oText)),
          zIndex: obj.zIndex
        }, obj.oStyle));
      }
    }
    var cps = new CPointStyle();
    

    var imgsObj = {};
    var imgs = ['images/target.png', 'https://static.easyicon.net/preview/122/1225510.gif',
      'https://static.easyicon.net/preview/121/1215367.gif', 'https://static.easyicon.net/preview/119/1191382.gif'
    ];
    function randomArr (arr) {
      return arr[parseInt(Math.random()*arr.length)];
    }

    var distance = document.getElementById('distance');

    var count = 20000;
    var features = new Array(count);
    var e = 4500000;
    for (var i = 0; i < count; ++i) {
      var coordinates = [2 * e * Math.random() - e, 2 * e * Math.random() - e];
      features[i] = new ol.Feature(new ol.geom.Point(coordinates));
      features[i].set('id', i);
    }

    var source = new ol.source.Vector({
      // features: features,
      loader: function () {
        let iarr = imgs.map(s => {
          return {src: s, size: [30,30]}
        })
        cps.imgsTocvs(iarr).then(args => {
          features.forEach((o, i) => {
            o.set('canvas', randomArr(args))
          })
          source.addFeatures(features);
        })
      }
    });

    var clusterSource = new ol.source.Cluster({
      distance: parseInt(distance.value, 10),
      source: source
    });

    var styleCache = {};
    var num = 0;
    var clusters = new ol.layer.Vector({
      source: clusterSource,
      style: function (feature) {
        let canvas = feature.get('features')[0].get('canvas');
        let ctx = canvas.getContext('2d');
        // ctx.font = '20px FontAwesome';
        // ctx.fillText('11');
        ctx.font="20px FontAwesome";
        // console.log(ctx.measureText("\uf2da"));
ctx.fillText("\uf2da",5,22);
        return [
          cps.olIcon(canvas, {zIndex: 2}),
          cps.olText({text: feature.get('features').length + '', fillColor: '#f00'})
        ];
      }
    });
    var raster = new ol.layer.Tile({
      source: new ol.source.OSM()
    });

    var map = new ol.Map({
      layers: [raster, clusters],
      target: 'map',
      view: new ol.View({
        center: [0, 0],
        zoom: 2
      })
    });

    distance.addEventListener('input', function () {
      clusterSource.setDistance(parseInt(distance.value, 10));
    });

  </script>
</body>

</html>
